"use strict";(self.webpackChunkmodio_docs=self.webpackChunkmodio_docs||[]).push([[674],{2636:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var t=s(4848),o=s(8453);const i={id:"cpp-subscribing",title:"Subscribing to UGC",slug:"/cppsdk/subscribing"},r="Subscribing to UGC",a={id:"game-integration/cppsdk/getting-started/cpp-subscribing",title:"Subscribing to UGC",description:"Now you've shown the user some UGC based on a query they've submitted through your UI, the next step is for the user to pick a piece of UGC they'd like to download and trigger an installation process.",source:"@site/public/en-us/game-integration/cppsdk/getting-started/cpp-subscribing-ugc.mdx",sourceDirName:"game-integration/cppsdk/getting-started",slug:"/cppsdk/subscribing",permalink:"/cppsdk/subscribing",draft:!1,unlisted:!1,editUrl:"https://github.com/modio/modio-docs/tree/main/public/en-us/game-integration/cppsdk/getting-started/cpp-subscribing-ugc.mdx",tags:[],version:"current",frontMatter:{id:"cpp-subscribing",title:"Subscribing to UGC",slug:"/cppsdk/subscribing"},sidebar:"sidebar",previous:{title:"Searching for UGC",permalink:"/cppsdk/searching-ugc"},next:{title:"Adding UGC",permalink:"/cppsdk/adding-ugc"}},d={},c=[{value:"Installation management and UGC filepaths",id:"installation-management-and-ugc-filepaths",level:2},{value:"UGC subscriptions",id:"ugc-subscriptions",level:2},{value:"External subscription changes",id:"external-subscription-changes",level:3},{value:"Checking the user subscription list",id:"checking-the-user-subscription-list",level:3},{value:"Retrieving UGC directory filepaths for loading",id:"retrieving-ugc-directory-filepaths-for-loading",level:3},{value:"Next steps",id:"next-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"subscribing-to-ugc",children:"Subscribing to UGC"}),"\n",(0,t.jsx)(n.p,{children:"Now you've shown the user some UGC based on a query they've submitted through your UI, the next step is for the user to pick a piece of UGC they'd like to download and trigger an installation process."}),"\n",(0,t.jsx)(n.p,{children:"This guide covers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#installation-management-and-ugc-filepaths",children:"Installation management and UGC filepaths"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#ugc-subscriptions",children:"UGC subscriptions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#next-steps",children:"Next steps"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"installation-management-and-ugc-filepaths",children:"Installation management and UGC filepaths"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"subscription"})," marks a piece of UGC as requiring installation, whereas an ",(0,t.jsx)(n.strong,{children:"unsubscription"})," indicates uninstallation."]}),"\n",(0,t.jsxs)(n.p,{children:["So, how do you actually control when the SDK does those things? After all, you don't want UGC to be uninstalled after your main program has loaded those files into memory, locking them from deletion. Likewise, you probably don't want to be using networking or processor resources during gameplay for downloading UGC. In order to give you control over when these processes occur, without forcing you to shut down the SDK entirely, you can call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," and ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#disablemodmanagement",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In order to display a notification to your users when UGC is finished installing or updating, ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," asks you to provide a callback. Because ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," is ",(0,t.jsx)(n.strong,{children:"not an async"})," function (ie it doesn't end with *Async), the function handler operates differently compared to other asynchronous results callbacks you use elsewhere in the SDK. A handler given to this function will be held by the SDK until a corresponding call to ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#disablemodmanagement",children:(0,t.jsx)(n.code,{children:"DisableModManagement"})})," or ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#shutdownasync",children:(0,t.jsx)(n.code,{children:"ShutdownAsync"})})," takes place. The handler will be invoked every time UGC is automatically installed, updated, or uninstalled by the SDK's internal event loop."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Modio::EnableModManagement([](Modio::ModManagementEvent ModEvent)\n{\n    if (ModEvent.Status && ModEvent.Event == Modio::ModManagementEvent::EventType::Installed)\n    {\n        std::cout << "Mod with ID: " << ModEvent.ID << " is installed" << std::endl;\n    }\n    else \n    {\n        std::cout << "Mod with ID: " << ModEvent.ID << " failed to install: " << ModEvent.Status.message() << std::endl;\n    }\n});\n\n// Some time later: check if there\'s a mod being installed, or more mods that require installation pending\nif (!Modio::IsModManagementBusy())\n{\n    // This will reset any in-progress installations to pending, so we\'re only calling it if nothing\'s being processed\n    Modio::DisableModManagement();\n}\n\n'})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Events are emitted based on actual changes to a mod's local state. For example, if a user unsubscribes to a mod that is in the middle of downloading, the download will be cancelled. Because the mod was never installed, however, a BeginUninstall event will ",(0,t.jsx)(n.strong,{children:"not"})," be emitted. Likewise, if a user subscribes to a mod which was already installed by another user on the system, Download/Install events will not be emitted because no download or installation is actually occurring (the mod files are shared, so there is no need to redownload or reinstall them)."]})}),"\n",(0,t.jsx)(n.h2,{id:"ugc-subscriptions",children:"UGC subscriptions"}),"\n",(0,t.jsx)(n.p,{children:"To build on the above, a user indicates they want to install UGC by 'subscribing' to it. The mod.io servers store these subscriptions, associating them with a particular user's mod.io account. When a user 'unsubscribes' UGC, they indicate that piece of UGC should be uninstalled from any device they're logged in on."}),"\n",(0,t.jsxs)(n.p,{children:["The API for managing subscriptions is simple and consists of a call to either ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#subscribetomodasync",children:(0,t.jsx)(n.code,{children:"SubscribeToModAsync"})})," or ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#unsubscribefrommodasync",children:(0,t.jsx)(n.code,{children:"UnsubscribeFromModAsync"})})," with the ID of the mod in question and a callback to receive the status of the request:"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["To subscribe to UGC, ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#enablemodmanagement",children:(0,t.jsx)(n.code,{children:"EnableModManagement"})})," must be called beforehand."]})}),"\n",(0,t.jsx)(n.p,{children:"When subscribing to UGC, you can also pass in a bool to indicate if you want to subscribe to all dependencies for the given UGC. If dependencies are also subscribed, the mod.io servers will also associate them with the current user."}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Currently when dependencies are included during subscription, they will not automatically be downloaded. To ensure the latest content is downloaded, ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," must be called after subscribing."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Subscription\nModio::SubscribeToModAsync(ModID, IncludeDependencies, [](Modio::ErrorCode ec)\n{\n    if (ec)\n    {\n        // Didn't subscribe, show a message to the user\n    }\n    else\n    {\n        // Successfully subscribed on the server\n    }\n});\n\n// Unsubscription\nModio::UnsubscribeFromModAsync(ModID, [](Modio::ErrorCode ec)\n{\n    if (ec)\n    {\n        // Couldn't unsubscribe, show error\n    }\n    else\n    {\n        // Server records unsubscription to remove the user's association to this mod\n    }\n});\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"external-subscription-changes",children:"External subscription changes"}),"\n",(0,t.jsxs)(n.p,{children:["Remember that the mod.io service is available as a website besides the integration within your application. Users can manage their subscriptions (and therefore installations) outside of your game. Consequently, you must query the server for any external subscription changes. To do this, use ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," to synchronise the server state with the SDK's local subscriptions:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"Modio::FetchExternalUpdatesAsync([](Modio::ErrorCode ec)\n{\n    if (ec)\n    {\n        // Couldn't fetch external subscription data, handle error\n    }\n    else\n    {\n        // The SDK's internal state synchronised. This is an acknowledgment of success\n    }\n});\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["You should call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," at particular times in your application when you want to ensure that the state is up-to-date. The mod.io SDK will apply rate-limiting internally if you try to call it too often."]})}),"\n",(0,t.jsxs)(n.p,{children:["In case you need to prepare for changes happening beforehand, call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#previewexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"PreviewExternalUpdatesAsync"})}),". This function retrieves a list of updates between the users local mod state, and the server-side state. It allows you to identify which piece of UGC will be modified when you call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#fetchexternalupdatesasync",children:(0,t.jsx)(n.code,{children:"FetchExternalUpdatesAsync"})})," next in order to perform any content management (such as unloading files) that might be required. Its use is very similar:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'Modio::PreviewExternalUpdatesAsync([](Modio::ErrorCode ec, std::map<Modio::ModID, Modio::UserSubscriptionList::ChangeType> ListOfChanges)\n{\n    if (ec)\n    {\n        // Couldn\'t preview external subscription data, handle error\n    }\n    else\n    {\n        // Take notice of the changes brought inside variable "ListOfChanges". It serves as acknowledgment of success\n    }\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"checking-the-user-subscription-list",children:"Checking the user subscription list"}),"\n",(0,t.jsxs)(n.p,{children:["In order to see which piece of UGC the user has subscribed to, call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryusersubscriptions",children:(0,t.jsx)(n.code,{children:"QueryUserSubscriptions"})})," to retrieve a collection of ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#ModCollectionEntry",children:(0,t.jsx)(n.code,{children:"ModCollectionEntry"})})," objects, one for each subscribed piece of UGC.\nEach of these objects contains the UGC's state, profile information, ID, and other data suitable for showing users a list of their subscriptions."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This collection includes UGC that are still in the process of being installed. Make sure to check the result of ",(0,t.jsx)(n.code,{children:"ModCollectionEntry::GetModState"})," before trying to load files from the UGC in this collection. Alternatively, use ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryuserinstallations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," as described in ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#retrieving-mod-directory-filepaths-for-loading",children:"Retrieving mod directory paths for loading"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["A distinction exists between functions ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryuserinstallations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," and ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#querysysteminstallations",children:(0,t.jsx)(n.code,{children:"QuerySystemInstallations"})}),". The first fetches the subset of the user's subscribed UGC that are installed and therefore ready for loading. ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryuserinstallations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," is more relevant for most cases to personalize the content shown to the user. On the other hand, a call to ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#querysysteminstallations",children:(0,t.jsx)(n.code,{children:"QuerySystemInstallations"})})," returns all mods installed on the system (including those the current user is subscribed to). This provides insight into UGC installed by other users."]}),"\n",(0,t.jsx)(n.p,{children:"If local space is a concern, here are some options to manage storage:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Execute ",(0,t.jsxs)(n.a,{href:"/cppsdk/refdocs/#querysysteminstallations",children:[(0,t.jsx)(n.code,{children:"QuerySystemInstallation"}),"s"]}),", let the user know space is limited and provide the chance to select UGC to uninstall. Then call ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#forceuninstallmodasync",children:(0,t.jsx)(n.code,{children:"ForceUninstallModAsync"})})," to remove UGC selected by the user."]}),"\n",(0,t.jsxs)(n.li,{children:["Execute ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryuserinstallations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})})," and prompt the user to unsubscribe from large UGC."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The first option focuses on the removal of any UGC the user has not interacted with, whereas the second option would actively uninstall UGC the user has previously considered and subscribed to. Consider other alternatives when designing your game to support UGC."}),"\n",(0,t.jsx)(n.h3,{id:"retrieving-ugc-directory-filepaths-for-loading",children:"Retrieving UGC directory filepaths for loading"}),"\n",(0,t.jsx)(n.p,{children:"Once the user can pick UGC and subscribe (i.e. mark them for installation), mod.io SDK management can alter the filesystem and retrieve UGC. We need to know where they are on the filesystem to load them into your gameplay."}),"\n",(0,t.jsxs)(n.p,{children:["The easiest way to do this is by using ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#queryuserinstallations",children:(0,t.jsx)(n.code,{children:"QueryUserInstallations"})}),". This function allows you to specify if you want to include outdated UGC or not. It returns a collection of ",(0,t.jsx)(n.a,{href:"/cppsdk/refdocs/#ModCollectionEntry",children:(0,t.jsx)(n.code,{children:"ModCollectionEntry"})})," objects that you can query for folder paths you can use to load files into your title."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:'std::vector<Modio::filesystem::path> ModPaths;\n\n// It iterates over all the installed mods that are up-to-date\nbool bIncludeOutdatedMods = false;\nfor (std::pair<Modio::ModID, Modio::ModCollectionEntry>& Entry : Modio::QueryUserInstallations(bIncludeOutdatedMods))\n{\n    ModPaths.push_back(Entry.second().GetPath());\n}\n\n// You can now append whatever filenames you expect in a mod to the paths and load those in\nfor (Modio::filesystem::path& Path : ModPaths)\n{\n    YourGame::FileHandle ModManifest = YourGame::OpenFile(Path / "mod_manifest.txt");\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsxs)(n.p,{children:["Now your users can search for and subscribe to UGC, you might want to start exploring ways for users to ",(0,t.jsx)(n.a,{href:"/cppsdk/adding-ugc",children:"Add UGC"})," to your game."]}),"\n",(0,t.jsxs)(n.p,{children:["If you've already done this, we recommend working your way through the ",(0,t.jsx)(n.a,{href:"/cppsdk/#c-sdk-core-setup-guides",children:"C++ SDK Getting Started Guides"})," as they will teach you how to implement the fundamentals of the C++ SDK before moving onto exploring our ",(0,t.jsx)(n.a,{href:"/features",children:"Features"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);